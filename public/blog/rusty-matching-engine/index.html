<html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="Systems Engineer | Rustacean | Backend Developer" name=description><meta content="Nam Dang" name=author><meta content="index, follow" name=robots><title>Nam (Viktor) Dang - Systems Engineer</title><link href=/favicon.svg rel=icon type=image/svg+xml><link as=font crossorigin href=/fonts/JetBrainsMono-Regular.woff2 rel=preload type=font/woff2><style>@font-face{font-family:JetBrains Mono;src:url(/fonts/JetBrainsMono-Regular.woff2)format("woff2");font-weight:400;font-style:normal;font-display:swap}@font-face{font-family:JetBrains Mono;src:url(/fonts/JetBrainsMono-Bold.woff2)format("woff2");font-weight:700;font-style:normal;font-display:swap}</style><link href=/style.css rel=stylesheet><body><main class=container><header class=header><div class=whoami><a href=/blog>cd ..</a></div><h1>Building a Matching Engine in Rust</h1><p class=date>Date: 2025-12-01 | Read time: 1 min</header><article class=post-content><p>For <strong>Outlaw</strong>, my HFT-style orderbook, I wanted <strong>sub-microsecond</strong> latency. Standard data structures were not enough.<h2 id=the-problem-with-padding>The Problem with Padding</h2><p>In Rust (and C), structs are aligned in memory.<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>struct </span><span>Order {
</span><span>    </span><span style=color:#bf616a>id</span><span>: </span><span style=color:#b48ead>u64</span><span>,    </span><span style=color:#65737e>// 8 bytes
</span><span>    </span><span style=color:#bf616a>active</span><span>: </span><span style=color:#b48ead>bool </span><span style=color:#65737e>// 1 byte
</span><span>    </span><span style=color:#65737e>// 7 bytes of PADDING here!
</span><span>}
</span></code></pre><p>That padding is wasted cache space. In HFT, L3 cache misses are death.<h2 id=the-solution-repr-c-packed>The Solution: <code>#[repr(C, packed)]</code></h2><p>I forced the compiler to pack the struct, but this comes with alignment penalties if you're not careful.<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span>#[</span><span style=color:#bf616a>repr</span><span>(C)]
</span><span style=color:#b48ead>struct </span><span>Order {
</span><span>    </span><span style=color:#bf616a>price</span><span>: </span><span style=color:#b48ead>u64</span><span>,
</span><span>    </span><span style=color:#bf616a>quantity</span><span>: </span><span style=color:#b48ead>u64</span><span>,
</span><span>    </span><span style=color:#bf616a>order_id</span><span>: </span><span style=color:#b48ead>u128</span><span>,
</span><span>}
</span></code></pre><h2 id=lock-free-logic>Lock-Free Logic</h2><p>Mutexes are slow. <code>RwLock</code> is slower.<p>I architected the engine as a <strong>Single-Threaded Event Loop</strong>.<ol><li>All incoming orders go into a Ring Buffer (LMAX Disruptor style).<li>A single consumer thread pulls orders and mutates the Orderbook.<li>No locks needed because only ONE thread touches the book.</ol><h2 id=binary-persistence>Binary Persistence</h2><p>JSON is slow. Protobuf is okay. Raw bytes are king.<p>I wrote a custom serializer that memcpys the struct directly to a memory-mapped file for crash recovery.<pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#65737e>// Pseudo-code
</span><span style=color:#b48ead>unsafe </span><span>{
</span><span>    std::ptr::copy_nonoverlapping(
</span><span>        &order as </span><span style=color:#b48ead>*const </span><span>_ as </span><span style=color:#b48ead>*const u8</span><span>,
</span><span>        buffer_ptr,
</span><span>        std::mem::size_of::&LTOrder>()
</span><span>    );
</span><span>}
</span></code></pre><p><em>Don't try this at home unless you know exactly what you are doing.</em><h2 id=result>Result</h2><p><strong>< 5 microseconds</strong> matching time per order. The engine runs faster than the network cards can deliver packets.</article><footer class=footer><p class=contact><code>$ contact --email nam.dt161@gmail.com --github @namdt1610</code></footer></main>