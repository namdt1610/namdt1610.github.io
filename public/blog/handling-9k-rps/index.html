<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="Systems Engineer | Rustacean | Backend Developer" name=description><meta content="Nam Dang" name=author><meta content="index, follow" name=robots><title>Nam (Viktok) Dang - Systems Engineer</title><link href=/favicon.svg rel=icon type=image/svg+xml><link as=font crossorigin href=/fonts/JetBrainsMono-Regular.woff2 rel=preload type=font/woff2><style>@font-face{font-family:JetBrains Mono;src:url(/fonts/JetBrainsMono-Regular.woff2)format("woff2");font-weight:400;font-style:normal;font-display:swap}@font-face{font-family:JetBrains Mono;src:url(/fonts/JetBrainsMono-Bold.woff2)format("woff2");font-weight:700;font-style:normal;font-display:swap}</style><link href=/style.css rel=stylesheet><body><main class=container><header class=header><div class=whoami><a href=/blog>cd ..</a></div><h1>How I Handled 9k RPS with Go Fiber and SQLite</h1><p class=date>Date: 2025-11-20 | Read time: 1 min</header><article class=post-content><p>I validated my <strong>Limited Drop Platform</strong> architecture by pushing it to the limit. The goal: handle a flash sale with thousands of concurrent users trying to buy a limited stock item.<h2 id=the-architecture>The Architecture</h2><ul><li><strong>Language:</strong> Go (1.23+)<li><strong>Web Framework:</strong> Fiber (Zero allocation)<li><strong>Database:</strong> SQLite (WAL Mode)<li><strong>Host:</strong> Local machine (Ryzen 5, 16GB RAM)</ul><h2 id=the-bottleneck-race-conditions>The Bottleneck: Race Conditions</h2><p>When 1,000 users try to buy the last item at the exact same millisecond, you have a race condition.<h3 id=naive-approach-wrong>Naive Approach (Wrong)</h3><pre class=language-go data-lang=go style=color:#c0c5ce;background-color:#2b303b><code class=language-go data-lang=go><span style=color:#bf616a>product </span><span>:= </span><span style=color:#bf616a>db</span><span>.</span><span style=color:#bf616a>GetProduct</span><span>(</span><span style=color:#bf616a>id</span><span>)
</span><span style=color:#b48ead>if </span><span style=color:#bf616a>product</span><span>.</span><span style=color:#bf616a>Stock </span><span>> </span><span style=color:#d08770>0 </span><span>{
</span><span>    </span><span style=color:#bf616a>product</span><span>.</span><span style=color:#bf616a>Stock</span><span>--
</span><span>    </span><span style=color:#bf616a>db</span><span>.</span><span style=color:#bf616a>Save</span><span>(</span><span style=color:#bf616a>product</span><span>)
</span><span>    </span><span style=color:#b48ead>return </span><span>"</span><span style=color:#a3be8c>Success</span><span>" </span><span style=color:#65737e>// FAILS under load
</span><span>}
</span></code></pre><p>This fails because 50 goroutines can read <code>Stock = 1</code> at the same time.<h3 id=the-fix-pessimistic-locking>The Fix: Pessimistic Locking</h3><p>I used <code>UPDATE ... WHERE</code> atomic queries to let the database handle the locking.<pre class=language-go data-lang=go style=color:#c0c5ce;background-color:#2b303b><code class=language-go data-lang=go><span style=color:#65737e>// Atomic decrement
</span><span style=color:#bf616a>result </span><span>:= </span><span style=color:#bf616a>db</span><span>.</span><span style=color:#bf616a>Exec</span><span>("</span><span style=color:#a3be8c>UPDATE products SET stock = stock - 1 WHERE id = ? AND stock > 0</span><span>", </span><span style=color:#bf616a>id</span><span>)
</span><span style=color:#b48ead>if </span><span style=color:#bf616a>result</span><span>.</span><span style=color:#bf616a>RowsAffected </span><span>== </span><span style=color:#d08770>0 </span><span>{
</span><span>    </span><span style=color:#b48ead>return </span><span>"</span><span style=color:#a3be8c>Sold Out</span><span>"
</span><span>}
</span><span style=color:#65737e>// Proceed to create order
</span></code></pre><h2 id=performance-tuning>Performance Tuning</h2><p>To hit 9,000 RPS, I had to optimize the hot path:<ol><li><strong>Prepared Statements</strong>: Disable re-parsing SQL for every query.<li><strong>Fiber Prefork</strong>: Use <code>SO_REUSEPORT</code> to spin up multiple Go processes (though on SQLite, single process usually wins due to lock contention).<li><strong>Zero Allocation</strong>: Avoid <code>fmt.Sprintf</code> in hot paths. Use <code>strconv</code>.</ol><h2 id=result>Result</h2><ul><li><strong>9k RPS</strong> sustained.<li><strong>p99 Latency:</strong> < 15ms.<li><strong>CPU Usage:</strong> 60%.</ul><p>Proof that a monolith is not just viable, it's often <strong>superior</strong> for raw throughput per dollar.</article><footer class=footer><p class=contact><code>$ contact --email nam.dt161@gmail.com --github @namdt1610</code></footer></main>