<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="Systems Engineer | Rustacean | Backend Developer" name=description><meta content="Nam Dang" name=author><meta content="index, follow" name=robots><title>Nam (Viktok) Dang - Systems Engineer</title><link href=/favicon.svg rel=icon type=image/svg+xml><link as=font crossorigin href=/fonts/JetBrainsMono-Regular.woff2 rel=preload type=font/woff2><style>@font-face{font-family:JetBrains Mono;src:url(/fonts/JetBrainsMono-Regular.woff2)format("woff2");font-weight:400;font-style:normal;font-display:swap}@font-face{font-family:JetBrains Mono;src:url(/fonts/JetBrainsMono-Bold.woff2)format("woff2");font-weight:700;font-style:normal;font-display:swap}</style><link href=/style.css rel=stylesheet><body><main class=container><header class=header><div class=whoami><a href=/blog>cd ..</a></div><h1>Why SQLite WAL Mode is Faster Than You Think</h1><p class=date>Date: 2025-10-15 | Read time: 1 min</header><article class=post-content><p>Everyone thinks SQLite is a toy database. "It doesn't handle concurrency!" they scream. "Use Postgres!" they yell.<p>They are wrong.<p>When properly configured with <strong>WAL (Write-Ahead Logging)</strong> mode, SQLite is a beast. I used it to handle <strong>9,000 requests per second</strong> on a single cheap VPS.<h2 id=the-myth-of-database-locks>The Myth of "Database Locks"</h2><p>By default, SQLite uses a rollback journal. This means:<ol><li>When writing, it locks the <em>entire</em> database file.<li>Readers have to wait.<li>Writers have to wait.</ol><p>This is shit for high concurrency.<h2 id=enter-wal-mode>Enter WAL Mode</h2><pre class=language-sql data-lang=sql style=color:#c0c5ce;background-color:#2b303b><code class=language-sql data-lang=sql><span>PRAGMA journal_mode = WAL;
</span><span>PRAGMA synchronous = NORMAL;
</span></code></pre><p>With WAL mode enabled:<ul><li><strong>Readers do not block writers.</strong><li><strong>Writers do not block readers.</strong><li>Changes are appended to a <code>-wal</code> file, then checkpointed back to the main DB.</ul><h2 id=the-batch-insert-trick>The "Batch Insert" Trick</h2><p>Syscalls are expensive. Opening a transaction is expensive.<p>If you insert 1,000 records one by one:<ul><li>1,000 filesystem syncs.<li>1,000 lock acquisitions.</ul><p>If you batch them:<pre class=language-go data-lang=go style=color:#c0c5ce;background-color:#2b303b><code class=language-go data-lang=go><span style=color:#bf616a>tx </span><span>:= </span><span style=color:#bf616a>db</span><span>.</span><span style=color:#bf616a>Begin</span><span>()
</span><span style=color:#b48ead>for </span><span style=color:#bf616a>_</span><span>, </span><span style=color:#bf616a>record </span><span>:= </span><span style=color:#b48ead>range </span><span style=color:#bf616a>records </span><span>{
</span><span>    </span><span style=color:#bf616a>tx</span><span>.</span><span style=color:#bf616a>Create</span><span>(&</span><span style=color:#bf616a>record</span><span>)
</span><span>}
</span><span style=color:#bf616a>tx</span><span>.</span><span style=color:#bf616a>Commit</span><span>()
</span></code></pre><p><strong>1 filesystem sync.</strong> That's how you get 100x performance.<h2 id=conclusion>Conclusion</h2><p>Stop over-engineering with Kubernetes and Microservices for your 100-user app. A single binary with SQLite running in WAL mode can take you further than you think.<p>Keep it simple. Keep it fast.</article><footer class=footer><p class=contact><code>$ contact --email nam.dt161@gmail.com --github @namdt1610</code></footer></main>